{"version":3,"sources":["../src/validate.js"],"names":["validString","ALPHABET","ALPHABET_LS47","validateMode","settings","mode","TypeError","validateMsg","message","length","Array","isArray","filter","line","forEach","validateHeaderData","headerData","validateKey","key","from","Set","validateNonce","nonce","validateSignature","signature","validateSettings","validator"],"mappings":"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","sourcesContent":["/** @module lc4/validate */\nimport { validString } from \"./helpers.js\";\nimport { ALPHABET, ALPHABET_LS47 } from \"./config.js\";\n\n/**\n * Validates the mode option of the settings\n * @param {Object} settings settings object\n * @param {String} settings.mode encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @throws {TypeError} when settings.mode is invalid\n * @returns {undefined}\n */\nexport function validateMode(settings) {\n    if (!(settings.mode === \"lc4\" || settings.mode === \"ls47\")) {\n        throw new TypeError(\n            \"Invalid mode!\\n\" + \"Mode may be either 'lc4' or 'ls47'.\"\n        );\n    }\n}\n\n/**\n * Validates the message of the settings\n * @param {Object} settings settings object\n * @param {(String|Array)} settings.message valid LC4 or LS47 message or array\n * of valid strings\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when no message is specified or the message is invalid\n * @return {undefined}\n */\nexport function validateMsg(settings) {\n    if (!settings.message || settings.message.length === 0) {\n        throw new TypeError(\"You must specify a message to encrypt\");\n    } else if (Array.isArray(settings.message)) {\n        return (\n            settings.message\n                // Allow empty lines\n                .filter(line => line !== \"\")\n                .forEach(line =>\n                    validateMsg({ message: line, mode: settings.mode })\n                )\n        );\n    } else if (!validString([...settings.message], settings.mode)) {\n        throw new TypeError(\n            \"Message contains invalid characters!\\n\" +\n                \"You may only use following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    }\n}\n\n/**\n * Validates the headerDate option of the settings\n * @param {Object} settings settings object\n * @param {String} [settings.headerData=null] optional valid header data\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when header data is specified but contains illegal\n * characters\n * @returns {undefined}\n */\nexport function validateHeaderData(settings) {\n    if (\n        settings.headerData &&\n        !validString([...settings.headerData], settings.mode)\n    ) {\n        throw new TypeError(\n            \"Invalid header data!\\n\" +\n                \"Header data may only contain following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    }\n}\n\n/**\n * Validates the key of the settings\n * @param {Object} settings settings object\n * @param {String} settings.key valid key (no illegal characters, no duplicate\n * characters if as long as alphabet) or password\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when key is not specified, too short or contains illegal\n * characters\n * @returns {undefined}\n */\nexport function validateKey(settings) {\n    if (!settings.key) {\n        throw new TypeError(\n            \"You must specify a (valid) key!\\n\" +\n                \"You may only use following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    } else if (!validString([...settings.key], settings.mode)) {\n        throw new TypeError(\n            \"Keyword for key generation contains invalid characters!\\n\" +\n                \"You may only use following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    } else if (\n        settings.key.length ===\n            (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET).length &&\n        Array.from(new Set([...settings.key])).length !== settings.key.length\n    ) {\n        throw new TypeError(\"Duplicate characters aren't allowed in key!\");\n    }\n}\n\n/**\n * Validates nonce option of the settings\n * @param {Object} settings settings object\n * @param {String} [settings.nonce=null] optional valid nonce\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when nonce is specified and too short (< 6 characters) or\n * contains illegal characters\n * @returns {undefined}\n */\nexport function validateNonce(settings) {\n    if (\n        settings.nonce &&\n        (!validString([...settings.nonce], settings.mode) ||\n            settings.nonce.length < 6)\n    ) {\n        throw new TypeError(\n            \"Invalid nonce!\\n\" +\n                \"Nonce may only contain following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET) +\n                \" and must be at least 6 characters long.\"\n        );\n    }\n}\n\n/**\n * Validates signature option of the settings\n * @param {Object} settings settings object\n * @param {String} [settings.signature=null] optional valid signature\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when signature is specified and too short (< 10\n * characters) or contains illegal characters\n * @returns {undefined}\n */\nexport function validateSignature(settings) {\n    if (\n        settings.signature &&\n        (!validString([...settings.signature], settings.mode) ||\n            settings.signature.length < 10)\n    ) {\n        throw new TypeError(\n            \"Invalid signature!\\n\" +\n                \"Signature may only contain following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET) +\n                \" and must be at least 10 characters long.\"\n        );\n    }\n}\n\n/**\n * Validate encryption/decryption LC4 settings\n * @param {Object} settings LC4 settings message\n * @param {String} settings.mode encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @param {String} settings.message valid LC4 or LS47 string\n * @param {String} settings.key valid LC4 or LS47 string\n * @param {String} [settings.signature=null] valid LC4 or LS47 string (at least\n * 10 characters long)\n * @param {String} [settings.headerData=null] valid LC4 or LS47 string\n * @param {String} [settings.nonce=null] valid LC4 or LS47 string (at least 6\n * characters long)\n * @throws {TypeError} When message and/or key and/or mode is missing or if\n * invalid value (invalid LC4 or LS47 string) is passed\n * @returns {undefined}\n */\nexport function validateSettings(settings) {\n    return [\n        validateMode,\n        validateMsg,\n        validateHeaderData,\n        validateKey,\n        validateNonce,\n        validateSignature\n    ].forEach(validator => validator(settings));\n}\n"],"file":"validate.js"}