{"version":3,"sources":["../src/validate.js"],"names":["validString","ALPHABET","ALPHABET_LS47","validateMode","settings","mode","TypeError","validateMsg","message","length","Array","isArray","forEach","line","validateHeaderData","headerData","validateKey","key","from","Set","validateNonce","nonce","validateSignature","signature","validateSettings","validator"],"mappings":"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","sourcesContent":["/** @module lc4/validate */\nimport { validString } from \"./helpers.js\";\nimport { ALPHABET, ALPHABET_LS47 } from \"./config.js\";\n\n/**\n * Validates the mode option of the settings\n * @param {Object} settings settings object\n * @param {String} settings.mode encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @throws {TypeError} when settings.mode is invalid\n * @returns {undefined}\n */\nexport function validateMode(settings) {\n    if (!(settings.mode === \"lc4\" || settings.mode === \"ls47\")) {\n        throw new TypeError(\n            \"Invalid mode!\\n\" + \"Mode may be either 'lc4' or 'ls47'.\"\n        );\n    }\n}\n\n/**\n * Validates the message of the settings\n * @param {Object} settings settings object\n * @param {(String|Array)} settings.message valid LC4 or LS47 message or array\n * of valid strings\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when no message is specified or the message is invalid\n * @return {undefined}\n */\nexport function validateMsg(settings) {\n    if (!settings.message || settings.message.length === 0) {\n        throw new TypeError(\"You must specify a message to encrypt\");\n    } else if (Array.isArray(settings.message)) {\n        return settings.message.forEach(line =>\n            validateMsg({ message: line, mode: settings.mode })\n        );\n    } else if (!validString([...settings.message], settings.mode)) {\n        throw new TypeError(\n            \"Message contains invalid characters!\\n\" +\n                \"You may only use following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    }\n}\n\n/**\n * Validates the headerDate option of the settings\n * @param {Object} settings settings object\n * @param {String} [settings.headerData=null] optional valid header data\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when header data is specified but contains illegal\n * characters\n * @returns {undefined}\n */\nexport function validateHeaderData(settings) {\n    if (\n        settings.headerData &&\n        !validString([...settings.headerData], settings.mode)\n    ) {\n        throw new TypeError(\n            \"Invalid header data!\\n\" +\n                \"Header data may only contain following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    }\n}\n\n/**\n * Validates the key of the settings\n * @param {Object} settings settings object\n * @param {String} settings.key valid key (no illegal characters, no duplicate\n * characters if as long as alphabet) or password\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when key is not specified, too short or contains illegal\n * characters\n * @returns {undefined}\n */\nexport function validateKey(settings) {\n    if (!settings.key) {\n        throw new TypeError(\n            \"You must specify a (valid) key!\\n\" +\n                \"You may only use following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    } else if (!validString([...settings.key], settings.mode)) {\n        throw new TypeError(\n            \"Keyword for key generation contains invalid characters!\\n\" +\n                \"You may only use following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET)\n        );\n    } else if (\n        settings.key.length ===\n            (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET).length &&\n        Array.from(new Set([...settings.key])).length !== settings.key.length\n    ) {\n        throw new TypeError(\"Duplicate characters aren't allowed in key!\");\n    }\n}\n\n/**\n * Validates nonce option of the settings\n * @param {Object} settings settings object\n * @param {String} [settings.nonce=null] optional valid nonce\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when nonce is specified and too short (< 6 characters) or\n * contains illegal characters\n * @returns {undefined}\n */\nexport function validateNonce(settings) {\n    if (\n        settings.nonce &&\n        (!validString([...settings.nonce], settings.mode) ||\n            settings.nonce.length < 6)\n    ) {\n        throw new TypeError(\n            \"Invalid nonce!\\n\" +\n                \"Nonce may only contain following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET) +\n                \" and must be at least 6 characters long.\"\n        );\n    }\n}\n\n/**\n * Validates signature option of the settings\n * @param {Object} settings settings object\n * @param {String} [settings.signature=null] optional valid signature\n * @param {String} [settings.mode=\"lc4\"] encryption/decryption algorithm. Can be\n * either \"lc4\" or \"ls47\"\n * @throws {TypeError} when signature is specified and too short (< 10\n * characters) or contains illegal characters\n * @returns {undefined}\n */\nexport function validateSignature(settings) {\n    if (\n        settings.signature &&\n        (!validString([...settings.signature], settings.mode) ||\n            settings.signature.length < 10)\n    ) {\n        throw new TypeError(\n            \"Invalid signature!\\n\" +\n                \"Signature may only contain following characters: \" +\n                (settings.mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET) +\n                \" and must be at least 10 characters long.\"\n        );\n    }\n}\n\n/**\n * Validate encryption/decryption LC4 settings\n * @param {Object} settings LC4 settings message\n * @param {String} settings.mode encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @param {String} settings.message valid LC4 or LS47 string\n * @param {String} settings.key valid LC4 or LS47 string\n * @param {String} [settings.signature=null] valid LC4 or LS47 string (at least\n * 10 characters long)\n * @param {String} [settings.headerData=null] valid LC4 or LS47 string\n * @param {String} [settings.nonce=null] valid LC4 or LS47 string (at least 6\n * characters long)\n * @throws {TypeError} When message and/or key and/or mode is missing or if\n * invalid value (invalid LC4 or LS47 string) is passed\n * @returns {undefined}\n */\nexport function validateSettings(settings) {\n    return [\n        validateMode,\n        validateMsg,\n        validateHeaderData,\n        validateKey,\n        validateNonce,\n        validateSignature\n    ].forEach(validator => validator(settings));\n}\n"],"file":"validate.js"}