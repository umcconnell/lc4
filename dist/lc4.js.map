{"version":3,"sources":["../src/lc4.js"],"names":["ALPHABET","GRIDSIZE","ALPHABET_LS47","GRIDSIZE_LS47","shuffle","randomElement","shiftRowRight","shiftColumnDown","position","printState","validString","generateKey","keyword","mode","alphabet","toLowerCase","Error","key","filter","char","indexOf","join","generateNonce","length","Array","fill","map","initState","size","S","k","Math","floor","encryptMsg","state","marker","msg","verbose","console","log","slice","row","col","step","code","x","i","j","y","out","decryptMsg"],"mappings":"AACA,OAASA,QAAT,CAAmBC,QAAnB,CAA6BC,aAA7B,CAA4CC,aAA5C,KAAiE,aAAjE,CACA,OACIC,OADJ,CAEIC,aAFJ,CAGIC,aAHJ,CAIIC,eAJJ,CAKIC,QALJ,CAMIC,UANJ,CAOIC,WAPJ,KAQO,cARP,CAmCA,MAAO,SAASC,CAAAA,WAAT,CAAqBC,CAAO,GAA5B,CAAsCC,CAAI,CAAG,KAA7C,CAAoD,CACvD,GAAIC,CAAAA,CAAQ,CAA0B,KAAvB,GAAAD,CAAI,CAACE,WAAL,GAA+Bf,QAA/B,CAA0CE,aAAzD,CAEA,GAAIU,CAAJ,EACQ,CAACF,WAAW,CAAC,CAAC,GAAGE,CAAJ,CAAD,CAAeC,CAAf,CADpB,CAEQ,KAAM,IAAIG,CAAAA,KAAJ,CACF,mGAEIF,CAHF,CAAN,CAQR,GAAIG,CAAAA,CAAG,CAAGb,OAAO,CACb,CAAC,GAAGU,CAAJ,EAAcI,MAAd,CAAqBC,CAAI,GACrBP,CADqB,EACa,CAAC,CAAzB,CAAAA,CAAO,CAACQ,OAAR,CAAgBD,CAAhB,CADd,CADa,CAAP,CAIRE,IAJQ,CAIH,EAJG,CAAV,CAMA,MAAO,CAACT,CAAO,CAAGA,CAAH,CAAa,EAArB,EAA2BK,CACrC,CA0BD,MAAO,SAASK,CAAAA,aAAT,CAAuBC,CAAM,CAAG,EAAhC,CAAoCV,CAAI,CAAG,KAA3C,CAAkD,CACrD,GAAa,CAAT,CAAAU,CAAJ,CACI,KAAM,IAAIP,CAAAA,KAAJ,CAAU,0CAAV,CAAN,CAGJ,MAAWQ,CAAAA,KAAJ,CAAUD,CAAV,EACFE,IADE,CACG,CADH,EAEFC,GAFE,CAEE,IACDrB,aAAa,CAAC,CACV,IAA2B,KAAvB,GAAAQ,CAAI,CAACE,WAAL,GAA+Bf,QAA/B,CAA0CE,aAA9C,CADU,CAAD,CAHd,EAOFmB,IAPE,CAOG,EAPH,CAQV,CASD,MAAO,SAASM,CAAAA,SAAT,CAAmBV,CAAnB,CAAwBJ,CAAI,CAAG,KAA/B,CAAsC,IACrCe,CAAAA,CAAI,CAAY,MAAT,GAAAf,CAAI,CAAcV,aAAd,CAA8BF,QADJ,CAErCa,CAAQ,CAAY,MAAT,GAAAD,CAAI,CAAcX,aAAd,CAA8BF,QAFR,CAIrC6B,CAAC,CAAOL,KAAJ,CAAUI,CAAV,EAAgBH,IAAhB,CAAqB,CAArB,EAAwBC,GAAxB,CAA4B,IAASF,KAAJ,CAAUI,CAAV,EAAgBH,IAAhB,CAAqB,CAArB,CAAjC,CAJiC,CAMzC,IAAK,GAAIK,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGhB,CAAQ,CAACS,MAA7B,CAAqCO,CAAC,EAAtC,CACID,CAAC,CAACE,IAAI,CAACC,KAAL,CAAWF,CAAC,CAAGF,CAAf,CAAD,CAAD,CAAwBE,CAAC,CAAGF,CAA5B,EAAoCd,CAAQ,CAACM,OAAT,CAAiBH,CAAG,CAACa,CAAD,CAApB,CAApC,CAGJ,MAAOD,CAAAA,CACV,CAgBD,MAAO,SAASI,CAAAA,UAAT,CAAoB,CAAEC,KAAK,CAALA,CAAF,CAASC,MAAM,CAANA,CAAT,CAAiBtB,IAAI,CAAJA,CAAjB,CAApB,CAA6CuB,CAA7C,CAAkDC,CAAO,GAAzD,CAAmE,CACtE,GAAIvB,CAAAA,CAAQ,CAAY,MAAT,GAAAD,CAAI,CAAcX,aAAd,CAA8BF,QAAjD,CACI4B,CAAI,CAAY,MAAT,GAAAf,CAAI,CAAcV,aAAd,CAA8BF,QAD7C,CASA,MANIoC,CAAAA,CAMJ,GALIC,OAAO,CAACC,GAAR,CAAa,eAAcH,CAAI,EAA/B,CAKJ,CAJIE,OAAO,CAACC,GAAR,CAAY,SAAZ,CAIJ,CAHI9B,UAAU,CAACyB,CAAK,CAACM,KAAN,EAAD,CAAgB,CAAEC,GAAG,CAAE,CAAC,CAAR,CAAWC,GAAG,CAAE,CAAC,CAAjB,CAAhB,CAAsCP,CAAtC,CAA8CtB,CAA9C,CAGd,EAAO,CAAC,GAAGuB,CAAJ,EACFV,GADE,CACE,CAACP,CAAD,CAAOwB,CAAP,GAAgB,IACbC,CAAAA,CAAI,CAAG9B,CAAQ,CAACM,OAAT,CAAiBD,CAAjB,CADM,CAEb,CAACsB,CAAD,CAAMC,CAAN,EAAalC,QAAQ,CAACoC,CAAD,CAAOV,CAAP,CAFR,CAIbW,CAAC,CAAG,CAACJ,CAAG,CAAGV,IAAI,CAACC,KAAL,CAAWE,CAAK,CAACC,CAAM,CAACW,CAAR,CAAL,CAAgBX,CAAM,CAACY,CAAvB,EAA4BnB,CAAvC,CAAP,EAAuDA,CAJ9C,CAKboB,CAAC,CAAG,CAACN,CAAG,CAAIR,CAAK,CAACC,CAAM,CAACW,CAAR,CAAL,CAAgBX,CAAM,CAACY,CAAvB,EAA4BnB,CAApC,EAA6CA,CALpC,CAObqB,CAAG,CAAGf,CAAK,CAACW,CAAD,CAAL,CAASG,CAAT,CAPO,CA+BjB,MAtBA1C,CAAAA,aAAa,CAAC4B,CAAD,CAAQO,CAAR,CAAaN,CAAb,CAAqBtB,CAArB,CAsBb,CArBIgC,CAAC,GAAKJ,CAqBV,GArBeO,CAAC,CAAG,CAACA,CAAC,CAAG,CAAL,EAAUpB,CAqB7B,EAnBArB,eAAe,CAAC2B,CAAD,CAAQc,CAAR,CAAWb,CAAX,CAAmBtB,CAAnB,CAmBf,CAlBImC,CAAC,GAAKN,CAkBV,GAlBeD,CAAG,CAAG,CAACA,CAAG,CAAG,CAAP,EAAYb,CAkBjC,EAhBAO,CAAM,CAACW,CAAP,CAAW,CAACX,CAAM,CAACW,CAAP,CAAWf,IAAI,CAACC,KAAL,CAAWiB,CAAG,CAAGrB,CAAjB,CAAZ,EAAsCA,CAgBjD,CAfAO,CAAM,CAACY,CAAP,CAAW,CAACZ,CAAM,CAACY,CAAP,CAAYE,CAAG,CAAGrB,CAAnB,EAA4BA,CAevC,CAbIS,CAaJ,GAZIC,OAAO,CAACC,GAAR,CAAa,SAAQI,CAAI,CAAG,CAAE,EAA9B,CAYJ,CAXIL,OAAO,CAACC,GAAR,CAAgBf,KAAJ,CAAiB,CAAP,CAAAI,CAAI,CAAO,CAArB,EAAwBH,IAAxB,CAA6B,GAA7B,EAAkCJ,IAAlC,CAAuC,EAAvC,CAAZ,CAWJ,CAVIZ,UAAU,CAACyB,CAAK,CAACM,KAAN,EAAD,CAAgB,CAAEC,GAAG,CAAHA,CAAF,CAAOC,GAAG,CAAEM,CAAZ,CAAhB,CAAiCb,CAAjC,CAAyCtB,CAAzC,CAUd,CATIyB,OAAO,CAACC,GAAR,CAAgBf,KAAJ,CAAiB,CAAP,CAAAI,CAAI,CAAO,CAArB,EAAwBH,IAAxB,CAA6B,GAA7B,EAAkCJ,IAAlC,CAAuC,EAAvC,CAAZ,CASJ,CARIiB,OAAO,CAACC,GAAR,CACK,eAAcpB,CAAK,wBAChBL,CAAQ,CAACmC,CAAD,CACX,SAHL,CAII,IAJJ,CAQJ,EAAOnC,CAAQ,CAACmC,CAAD,CAClB,CAjCE,EAkCF5B,IAlCE,CAkCG,EAlCH,CAmCV,CAgBD,MAAO,SAAS6B,CAAAA,UAAT,CAAoB,CAAEhB,KAAK,CAALA,CAAF,CAASC,MAAM,CAANA,CAAT,CAAiBtB,IAAI,CAAJA,CAAjB,CAApB,CAA6CuB,CAA7C,CAAkDC,CAAlD,CAA2D,CAC9D,GAAIvB,CAAAA,CAAQ,CAAY,MAAT,GAAAD,CAAI,CAAcX,aAAd,CAA8BF,QAAjD,CACI4B,CAAI,CAAY,MAAT,GAAAf,CAAI,CAAcV,aAAd,CAA8BF,QAD7C,CASA,MANIoC,CAAAA,CAMJ,GALIC,OAAO,CAACC,GAAR,CAAa,eAAcH,CAAI,EAA/B,CAKJ,CAJIE,OAAO,CAACC,GAAR,CAAY,SAAZ,CAIJ,CAHI9B,UAAU,CAACyB,CAAK,CAACM,KAAN,EAAD,CAAgB,CAAEC,GAAG,CAAE,CAAC,CAAR,CAAWC,GAAG,CAAE,CAAC,CAAjB,CAAhB,CAAsCP,CAAtC,CAA8CtB,CAA9C,CAGd,EAAO,CAAC,GAAGuB,CAAJ,EACFV,GADE,CACE,CAACP,CAAD,CAAOwB,CAAP,GAAgB,IACbC,CAAAA,CAAI,CAAG9B,CAAQ,CAACM,OAAT,CAAiBD,CAAjB,CADM,CAEb,CAAC0B,CAAD,CAAIG,CAAJ,EAASxC,QAAQ,CAACoC,CAAD,CAAOV,CAAP,CAFJ,CAIbO,CAAG,CAAG,CAACI,CAAC,CAAGd,IAAI,CAACC,KAAL,CAAWE,CAAK,CAACC,CAAM,CAACW,CAAR,CAAL,CAAgBX,CAAM,CAACY,CAAvB,EAA4BnB,CAAvC,CAAL,EAAqDA,CAJ9C,CAKbc,CAAG,CAAG,CAACM,CAAC,CAAId,CAAK,CAACC,CAAM,CAACW,CAAR,CAAL,CAAgBX,CAAM,CAACY,CAAvB,EAA4BnB,CAAlC,EAA2CA,CALpC,CAOP,CAAN,CAAAa,CAPa,GAOJA,CAAG,EAAIb,CAPH,EAQP,CAAN,CAAAc,CARa,GAQJA,CAAG,EAAId,CARH,EAUjB,GAAIqB,CAAAA,CAAG,CAAGf,CAAK,CAACO,CAAD,CAAL,CAAWC,CAAX,CAAV,CAwBA,MAtBApC,CAAAA,aAAa,CAAC4B,CAAD,CAAQO,CAAR,CAAaN,CAAb,CAAqBtB,CAArB,CAsBb,CArBIgC,CAAC,GAAKJ,CAqBV,GArBeO,CAAC,CAAG,CAACA,CAAC,CAAG,CAAL,EAAUpB,CAqB7B,EAnBArB,eAAe,CAAC2B,CAAD,CAAQc,CAAR,CAAWb,CAAX,CAAmBtB,CAAnB,CAmBf,CAlBImC,CAAC,GAAKN,CAkBV,GAlBeD,CAAG,CAAG,CAACA,CAAG,CAAG,CAAP,EAAYb,CAkBjC,EAhBAO,CAAM,CAACW,CAAP,CAAW,CAACX,CAAM,CAACW,CAAP,CAAWf,IAAI,CAACC,KAAL,CAAWY,CAAI,CAAGhB,CAAlB,CAAZ,EAAuCA,CAgBlD,CAfAO,CAAM,CAACY,CAAP,CAAW,CAACZ,CAAM,CAACY,CAAP,CAAYH,CAAI,CAAGhB,CAApB,EAA6BA,CAexC,CAbIS,CAaJ,GAZIC,OAAO,CAACC,GAAR,CAAa,SAAQI,CAAI,CAAG,CAAE,EAA9B,CAYJ,CAXIL,OAAO,CAACC,GAAR,CAAgBf,KAAJ,CAAiB,CAAP,CAAAI,CAAI,CAAO,CAArB,EAAwBH,IAAxB,CAA6B,GAA7B,EAAkCJ,IAAlC,CAAuC,EAAvC,CAAZ,CAWJ,CAVIZ,UAAU,CAACyB,CAAK,CAACM,KAAN,EAAD,CAAgB,CAAEC,GAAG,CAAHA,CAAF,CAAOC,GAAG,CAAEM,CAAZ,CAAhB,CAAiCb,CAAjC,CAAyCtB,CAAzC,CAUd,CATIyB,OAAO,CAACC,GAAR,CAAgBf,KAAJ,CAAiB,CAAP,CAAAI,CAAI,CAAO,CAArB,EAAwBH,IAAxB,CAA6B,GAA7B,EAAkCJ,IAAlC,CAAuC,EAAvC,CAAZ,CASJ,CARIiB,OAAO,CAACC,GAAR,CACK,eAAcpB,CAAK,wBAChBL,CAAQ,CAACmC,CAAD,CACX,SAHL,CAII,IAJJ,CAQJ,EAAOnC,CAAQ,CAACmC,CAAD,CAClB,CApCE,EAqCF5B,IArCE,CAqCG,EArCH,CAsCV","sourcesContent":["/** @module lc4/lc4 */\nimport { ALPHABET, GRIDSIZE, ALPHABET_LS47, GRIDSIZE_LS47 } from \"./config.js\";\nimport {\n    shuffle,\n    randomElement,\n    shiftRowRight,\n    shiftColumnDown,\n    position,\n    printState,\n    validString\n} from \"./helpers.js\";\n\n/**\n * Generate a valid random LC4 or LS47 key\n * @param {String} [keyword=false] keyword to base key off (less secure) or\n * falsy value if key shouldn't be based off a keyword\n * @param {String} [mode=\"lc4\"] encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @example <caption>Generate a random key</caption>\n * let { generateKey } = require(\"lc4\");\n *\n * generateKey();\n * @example <caption>Generate a random LS47 key with keword</caption>\n * let { generateKey } = require(\"lc4\");\n *\n * generateKey(\"hello\", \"ls47\");\n * @example <caption>Encrypt a message with a random key</caption>\n * const { encrypt, generateKey } = require(\"lc4\");\n *\n * encrypt({\n *     message: \"hello_world\",\n *     key: generateKey(),\n * });\n * @throws {Error} Will throw an error if the keyword contains invalid LC4 or\n * LS47 characters\n * @returns {String} a valid LC4 or LS47 key\n */\nexport function generateKey(keyword = false, mode = \"lc4\") {\n    let alphabet = mode.toLowerCase() === \"lc4\" ? ALPHABET : ALPHABET_LS47;\n\n    if (keyword) {\n        if (!validString([...keyword], mode))\n            throw new Error(\n                \"Keyword for key generation contains invalid characters!\\n\" +\n                    \"You may only use following characters: \" +\n                    alphabet\n            );\n    }\n\n    // Shuffle alphabet without letters already in keyword\n    let key = shuffle(\n        [...alphabet].filter(char =>\n            keyword ? keyword.indexOf(char) > -1 : true\n        )\n    ).join(\"\");\n\n    return (keyword ? keyword : \"\") + key;\n}\n\n/**\n * Generate a valid random LC4 or LS47 nonce\n * @param {Number} [length=10] length of nonce (at least 6)\n * @param {String} [mode=\"lc4\"] encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @example <caption>Generate a random nonce</caption>\n * let { generateNonce } = require(\"lc4\");\n *\n * generateNonce();\n * @example <caption>Generate a random LS47 nonce</caption>\n * let { generateNonce } = require(\"lc4\");\n *\n * generateNonce(10, \"ls47\");\n * @example <caption>Encrypt a message with a random nonce</caption>\n * const { encrypt, generateKey, generateNonce } = require(\"lc4\");\n *\n * encrypt({\n *     message: \"Lorem Ipsum\",\n *     key: generateKey(),\n *     nonce: generateNonce()\n * })\n * @throws {Error} Will throw an error if length is smaller than 6\n * @returns {String} a valid LC4 or LS47 nonce\n */\nexport function generateNonce(length = 10, mode = \"lc4\") {\n    if (length < 6) {\n        throw new Error(\"Nonce must be at least 6 characters long\");\n    }\n\n    return new Array(length)\n        .fill(0)\n        .map(_ =>\n            randomElement([\n                ...(mode.toLowerCase() === \"lc4\" ? ALPHABET : ALPHABET_LS47)\n            ])\n        )\n        .join(\"\");\n}\n\n/**\n * Populate a state matrix by filling in a key row by row\n * @param {(String|Array)} key key string or array\n * @param {String} [mode=\"lc4\"] encryption/decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @returns {Array} state matrix\n */\nexport function initState(key, mode = \"lc4\") {\n    let size = mode === \"ls47\" ? GRIDSIZE_LS47 : GRIDSIZE,\n        alphabet = mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET;\n\n    let S = new Array(size).fill(0).map(_ => new Array(size).fill(0));\n\n    for (let k = 0; k < alphabet.length; k++) {\n        S[Math.floor(k / size)][k % size] = alphabet.indexOf(key[k]);\n    }\n\n    return S;\n}\n\n/**\n * Encrypt a cleartext message and change the environment\n * @param {Object} env environment object\n * @param {Array} env.state state matrix\n * @param {Object} env.marker marker object representing active element\n * @param {Number} env.marker.i row of the marker in the state\n * @param {Number} env.marker.j column of the marker in the state\n * @param {String} env.mode encryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @param {String} msg cleartext message\n * @param {Boolean} [verbose=false] boolean indicating wether verbose mode\n * should be used (will print out intermediate steps)\n * @returns {String} ciphertext message\n */\nexport function encryptMsg({ state, marker, mode }, msg, verbose = false) {\n    let alphabet = mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET,\n        size = mode === \"ls47\" ? GRIDSIZE_LS47 : GRIDSIZE;\n\n    if (verbose) {\n        console.log(`Encrypting: ${msg}`);\n        console.log(\"step: 0\");\n        printState(state.slice(), { row: -1, col: -1 }, marker, mode);\n    }\n\n    return [...msg]\n        .map((char, step) => {\n            let code = alphabet.indexOf(char);\n            let [row, col] = position(code, state);\n\n            let x = (row + Math.floor(state[marker.i][marker.j] / size)) % size;\n            let y = (col + (state[marker.i][marker.j] % size)) % size;\n\n            let out = state[x][y];\n\n            shiftRowRight(state, row, marker, mode);\n            if (x === row) y = (y + 1) % size;\n\n            shiftColumnDown(state, y, marker, mode);\n            if (y === col) row = (row + 1) % size;\n\n            marker.i = (marker.i + Math.floor(out / size)) % size;\n            marker.j = (marker.j + (out % size)) % size;\n\n            if (verbose) {\n                console.log(`step: ${step + 1}`);\n                console.log(new Array(size * 3 - 2).fill(\"-\").join(\"\"));\n                printState(state.slice(), { row, col: y }, marker, mode);\n                console.log(new Array(size * 3 - 2).fill(\"-\").join(\"\"));\n                console.log(\n                    `pt: \\x1b[31m${char}\\x1b[0m  ct: \\x1b[31m${\n                        alphabet[out]\n                    }\\x1b[0m`,\n                    \"\\n\"\n                );\n            }\n\n            return alphabet[out];\n        })\n        .join(\"\");\n}\n\n/**\n * Decrypt a ciphertext message and change the environment\n * @param {Object} env environment object\n * @param {Array} env.state state matrix\n * @param {Object} env.marker marker object representing active element\n * @param {Number} env.marker.i row of the marker in the state\n * @param {Number} env.marker.j column of the marker in the state\n * @param {Strin} env.mode decryption algorithm. Can be either\n * \"lc4\" or \"ls47\"\n * @param {String} msg ciphertext message\n * @param {Boolean} [verbose=false] boolean indicating wether verbose mode\n * should be used (will print out intermediate steps)\n * @returns {String} cleartext message\n */\nexport function decryptMsg({ state, marker, mode }, msg, verbose) {\n    let alphabet = mode === \"ls47\" ? ALPHABET_LS47 : ALPHABET,\n        size = mode === \"ls47\" ? GRIDSIZE_LS47 : GRIDSIZE;\n\n    if (verbose) {\n        console.log(`Decrypting: ${msg}`);\n        console.log(\"step: 0\");\n        printState(state.slice(), { row: -1, col: -1 }, marker, mode);\n    }\n\n    return [...msg]\n        .map((char, step) => {\n            let code = alphabet.indexOf(char);\n            let [x, y] = position(code, state);\n\n            let row = (x - Math.floor(state[marker.i][marker.j] / size)) % size;\n            let col = (y - (state[marker.i][marker.j] % size)) % size;\n\n            if (row < 0) row += size;\n            if (col < 0) col += size;\n\n            let out = state[row][col];\n\n            shiftRowRight(state, row, marker, mode);\n            if (x === row) y = (y + 1) % size;\n\n            shiftColumnDown(state, y, marker, mode);\n            if (y === col) row = (row + 1) % size;\n\n            marker.i = (marker.i + Math.floor(code / size)) % size;\n            marker.j = (marker.j + (code % size)) % size;\n\n            if (verbose) {\n                console.log(`step: ${step + 1}`);\n                console.log(new Array(size * 3 - 2).fill(\"-\").join(\"\"));\n                printState(state.slice(), { row, col: y }, marker, mode);\n                console.log(new Array(size * 3 - 2).fill(\"-\").join(\"\"));\n                console.log(\n                    `ct: \\x1b[31m${char}\\x1b[0m  pt: \\x1b[31m${\n                        alphabet[out]\n                    }\\x1b[0m`,\n                    \"\\n\"\n                );\n            }\n\n            return alphabet[out];\n        })\n        .join(\"\");\n}\n"],"file":"lc4.js"}