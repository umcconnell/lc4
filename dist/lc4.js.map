{"version":3,"sources":["../src/lc4.js"],"names":["ALPHABET","GRIDSIZE","shuffle","randomElement","shiftRowRight","shiftColumnDown","position","printState","validLC4","generateKey","keyword","Error","key","filter","char","indexOf","join","generateNonce","length","Array","fill","map","initState","S","k","Math","floor","encryptMsg","state","marker","msg","verbose","console","log","slice","row","col","step","code","x","i","j","y","out","decryptMsg"],"mappings":"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","sourcesContent":["/** @module lc4/lc4 */\nimport { ALPHABET, GRIDSIZE } from \"./config.js\";\nimport {\n    shuffle,\n    randomElement,\n    shiftRowRight,\n    shiftColumnDown,\n    position,\n    printState,\n    validLC4\n} from \"./helpers.js\";\n\n/**\n * Generate a valid random LC4 key\n * @param {String} [keyword=false] keyword to base key off (less secure)\n * @example <caption>Generate a random key</caption>\n * let { generateKey } = require(\"lc4\");\n *\n * generateKey();\n * @example <caption>Encrypt a message with a random key</caption>\n * const { encrypt, generateKey } = require(\"lc4\");\n *\n * encrypt({\n *     message: \"hello_world\",\n *     key: generateKey(),\n * });\n * @throws {Error} Will throw an error if the keyword contains invalid LC4\n * characters\n * @returns {String} a valid LC4 key\n */\nexport function generateKey(keyword = false) {\n    if (keyword) {\n        if (!validLC4([...keyword]))\n            throw new Error(\n                \"Keyword for key generation contains invalid characters!\\n\" +\n                    \"You may only use following characters: \" +\n                    ALPHABET\n            );\n    }\n\n    // Shuffle alphabet without letters already in keyword\n    let key = shuffle(\n        [...ALPHABET].filter(char =>\n            keyword ? keyword.indexOf(char) > -1 : true\n        )\n    ).join(\"\");\n\n    return (keyword ? keyword : \"\") + key;\n}\n\n/**\n * Generate a valid random LC4 nonce\n * @param {Number} [length=10] length of nonce (at least 6)\n * @example <caption>Generate a random nonce</caption>\n * let { generateNonce } = require(\"lc4\");\n *\n * generateNonce();\n * @example <caption>Encrypt a message with a random nonce</caption>\n * const { encrypt, generateKey, generateNonce } = require(\"lc4\");\n *\n * encrypt({\n *     message: \"Lorem Ipsum\",\n *     key: generateKey(),\n *     nonce: generateNonce()\n * })\n * @throws {Error} Will throw an error if length is smaller than 6\n * @returns {String} a valid LC4 nonce\n */\nexport function generateNonce(length = 10) {\n    if (length < 6) {\n        throw new Error(\"Nonce must be at least 6 characters long\");\n    }\n\n    return new Array(length)\n        .fill(0)\n        .map(_ => randomElement([...ALPHABET]))\n        .join(\"\");\n}\n\n/**\n * Populate a state matrix by filling in a key row by row\n * @param {(String|Key)} key key string or array\n * @returns {Array} state matrix\n */\nexport function initState(key) {\n    let S = new Array(GRIDSIZE).fill(0).map(_ => new Array(GRIDSIZE).fill(0));\n\n    for (let k = 0; k < ALPHABET.length; k++) {\n        S[Math.floor(k / GRIDSIZE)][k % GRIDSIZE] = ALPHABET.indexOf(key[k]);\n    }\n\n    return S;\n}\n\n/**\n * Encrypt a cleartext message and change the environment\n * @param {Object} env environment object\n * @param {Array} env.state state matrix\n * @param {Object} env.marker marker object representing active element\n * @param {Number} env.marker.i row of the marker in the state\n * @param {Number} env.marker.j column of the marker in the state\n * @param {String} msg cleartext message\n * @param {Boolean} [verbose=false] boolean indicating wether verbose mode\n * should be used (will print out intermediate steps)\n * @returns {String} ciphertext message\n */\nexport function encryptMsg({ state, marker }, msg, verbose = false) {\n    if (verbose) {\n        console.log(`Encrypting: ${msg}`);\n        console.log(\"step: 0\");\n        printState(state.slice(), { row: -1, col: -1 }, marker);\n    }\n\n    return [...msg]\n        .map((char, step) => {\n            let code = ALPHABET.indexOf(char);\n            let [row, col] = position(code, state);\n\n            let x =\n                (row + Math.floor(state[marker.i][marker.j] / GRIDSIZE)) %\n                GRIDSIZE;\n            let y = (col + (state[marker.i][marker.j] % GRIDSIZE)) % GRIDSIZE;\n\n            let out = state[x][y];\n\n            shiftRowRight(state, row, marker);\n            if (x === row) y = (y + 1) % GRIDSIZE;\n\n            shiftColumnDown(state, y, marker);\n            if (y === col) row = (row + 1) % GRIDSIZE;\n\n            marker.i = (marker.i + Math.floor(out / GRIDSIZE)) % GRIDSIZE;\n            marker.j = (marker.j + (out % GRIDSIZE)) % GRIDSIZE;\n\n            if (verbose) {\n                console.log(`step: ${step + 1}`);\n                console.log(new Array(GRIDSIZE * 3 - 2).fill(\"-\").join(\"\"));\n                printState(state.slice(), { row, col: y }, marker);\n                console.log(new Array(GRIDSIZE * 3 - 2).fill(\"-\").join(\"\"));\n                console.log(\n                    `pt: \\x1b[31m${char}\\x1b[0m  ct: \\x1b[31m${\n                        ALPHABET[out]\n                    }\\x1b[0m`,\n                    \"\\n\"\n                );\n            }\n\n            return ALPHABET[out];\n        })\n        .join(\"\");\n}\n\n/**\n * Decrypt a ciphertext message and change the environment\n * @param {Object} env environment object\n * @param {Array} env.state state matrix\n * @param {Object} env.marker marker object representing active element\n * @param {Number} env.marker.i row of the marker in the state\n * @param {Number} env.marker.j column of the marker in the state\n * @param {String} msg ciphertext message\n * @param {Boolean} [verbose=false] boolean indicating wether verbose mode\n * should be used (will print out intermediate steps)\n * @returns {String} cleartext message\n */\nexport function decryptMsg({ state, marker }, msg, verbose) {\n    if (verbose) {\n        console.log(`Decrypting: ${msg}`);\n        console.log(\"step: 0\");\n        printState(state.slice(), { row: -1, col: -1 }, marker);\n    }\n\n    return [...msg]\n        .map((char, step) => {\n            let code = ALPHABET.indexOf(char);\n            let [x, y] = position(code, state);\n\n            let row =\n                (x - Math.floor(state[marker.i][marker.j] / GRIDSIZE)) %\n                GRIDSIZE;\n            let col = (y - (state[marker.i][marker.j] % GRIDSIZE)) % GRIDSIZE;\n\n            if (row < 0) row += GRIDSIZE;\n            if (col < 0) col += GRIDSIZE;\n\n            let out = state[row][col];\n\n            shiftRowRight(state, row, marker);\n            if (x === row) y = (y + 1) % GRIDSIZE;\n\n            shiftColumnDown(state, y, marker);\n            if (y === col) row = (row + 1) % GRIDSIZE;\n\n            marker.i = (marker.i + Math.floor(code / GRIDSIZE)) % GRIDSIZE;\n            marker.j = (marker.j + (code % GRIDSIZE)) % GRIDSIZE;\n\n            if (verbose) {\n                console.log(`step: ${step + 1}`);\n                console.log(new Array(GRIDSIZE * 3 - 2).fill(\"-\").join(\"\"));\n                printState(state.slice(), { row, col: y }, marker);\n                console.log(new Array(GRIDSIZE * 3 - 2).fill(\"-\").join(\"\"));\n                console.log(\n                    `ct: \\x1b[31m${char}\\x1b[0m  pt: \\x1b[31m${\n                        ALPHABET[out]\n                    }\\x1b[0m`,\n                    \"\\n\"\n                );\n            }\n\n            return ALPHABET[out];\n        })\n        .join(\"\");\n}\n"],"file":"lc4.js"}