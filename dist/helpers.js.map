{"version":3,"sources":["../src/helpers.js"],"names":["ALPHABET","GRIDSIZE","escapeToLC4","string","replace","toLowerCase","filter","char","indexOf","join","shuffle","arr","slice","temp","i","l","length","Math","floor","random","randomElement","shiftRowRight","state","row","marker","j","shiftColumnDown","col","shiftRow","last","map","position","vector","column","printState","chara","JSON","parse","stringify","markerChar","console","log","out","validLC4","input","every"],"mappings":"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","sourcesContent":["/** @module lc4/helpers */\nimport { ALPHABET, GRIDSIZE } from \"./config.js\";\n\n/**\n * Escape string to valid LC4 string\n * @param {String} string (invalid) LC4 string\n * @example\n * escapeToLC4(\"Hello World! This is the 10th test!\");\n *\n * //=> \"hello_world_this_is_the__#th_test\"\n * @returns {String} valid LC4 string\n */\nexport function escapeToLC4(string) {\n    return [\n        ...string\n            .replace(/0/g, \"#\")\n            .replace(/1/g, \"_\")\n            .replace(/\\u00dc/g, \"Ue\")\n            .replace(/\\u00fc/g, \"ue\")\n            .replace(/\\u00c4/g, \"Ae\")\n            .replace(/\\u00e4/g, \"ae\")\n            .replace(/\\u00d6/g, \"Oe\")\n            .replace(/\\u00f6/g, \"oe\")\n            .replace(/\\u00df/g, \"ss\")\n            .replace(/\\s/g, \"_\")\n            .toLowerCase()\n    ]\n        .filter(char => ALPHABET.indexOf(char) > -1)\n        .join(\"\");\n}\n\n/**\n * Fisher-Yates array Shuffle\n * @param {Array} arr input array to be shuffled\n * @returns {Array} shuffled array\n */\nexport function shuffle(arr) {\n    // Copy the array\n    arr = arr.slice();\n\n    // Fisher-Yates Shuffle\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n    let l = arr.length,\n        temp,\n        i;\n\n    while (l) {\n        i = Math.floor(Math.random() * l--);\n\n        temp = arr[l];\n        arr[l] = arr[i];\n        arr[i] = temp;\n    }\n\n    return arr;\n}\n\n/**\n * Pick a random element from an array\n * @param {Array} arr input array to pick element from\n * @returns {*} a random element from the array\n */\nexport function randomElement(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Shift given row in the state matrix and move the marker if needed\n * @param {Array} state state matrix\n * @param {Number} row index of row to shift\n * @param {Object} marker marker object representing active element\n * @param {Number} marker.i row of the marker in the state\n * @param {Number} marker.j column of the marker in the state\n * @returns {Array} updated state matrix\n */\nexport function shiftRowRight(state, row, marker) {\n    state[row] = [\n        state[row][state[row].length - 1],\n        ...state[row].slice(0, -1)\n    ];\n\n    if (marker.i === row) marker.j = (marker.j + 1) % GRIDSIZE;\n\n    return state;\n}\n\n/**\n * Shift given column in the state matrix and move the marker if needed\n * @param {Array} state state matrix\n * @param {Number} col index of column to shift\n * @param {Object} marker marker object representing active element\n * @param {Number} marker.i row of the marker in the state\n * @param {Number} marker.j column of the marker in the state\n * @returns {Array} updated state matrix\n */\nexport function shiftColumnDown(state, col, marker) {\n    let shiftRow = GRIDSIZE - 1,\n        last = state[shiftRow][col];\n\n    state = state.map(row => {\n        let temp = row[col];\n        row[col] = last;\n        last = temp;\n        shiftRow = (shiftRow + 1) % GRIDSIZE;\n        return row;\n    });\n\n    if (marker.j === col) marker.i = (marker.i + 1) % GRIDSIZE;\n\n    return state;\n}\n\n/**\n * Return the coordinates of given search element in the state matrix\n * @param {*} char search element\n * @param {Array} state state matrix\n * @returns {Array} position vector in the form [`row`, `column`]\n */\nexport function position(char, state) {\n    let vector = [];\n\n    for (let row = 0; row < state.length; row++) {\n        let column = state[row].indexOf(char);\n\n        if (column > -1) {\n            vector = [row, column];\n            break;\n        }\n    }\n\n    return vector;\n}\n\n/**\n * Print out state for verbose mode\n * @param {Array} state state array to print out\n * @param {Object} chara input character reference being encrypted/decrypted\n * @param {Number} chara.row row of input character in the state matrix\n * (-1 for no input character)\n * @param {Number} chara.col column of input character in the state matrix\n * (-1 for no input character)\n * @param {Object} marker marker object representing active element\n * @param {Number} marker.i row of the marker in the state\n * @param {Number} marker.j column of the marker in the state\n * @return {undefined}\n */\nexport function printState(state, chara, marker) {\n    // Deep-copy state\n    state = JSON.parse(JSON.stringify(state)).map(row =>\n        row.map(char => ALPHABET[char])\n    );\n\n    let markerChar = \"\\x1b[31m@\\x1b[0m\";\n    state[marker.i][marker.j] += markerChar;\n\n    console.log(\n        state\n            .map((row, i) => {\n                let out = row\n                    .map((char, j) =>\n                        i === chara.row || j === chara.col\n                            ? `\\x1b[32m${char}\\x1b[0m`\n                            : char\n                    )\n                    .join(\"  \");\n\n                return i === marker.i\n                    ? out.replace(`${markerChar} `, markerChar)\n                    : out;\n            })\n            .join(\"\\n\")\n    );\n}\n\n/**\n * Determine if input contains only valid LC4 characters\n * @param {Array} input input array\n * @returns {Boolean} indicating if input is valid LC4\n */\nexport function validLC4(input) {\n    return input.every(char => ALPHABET.indexOf(char) > -1);\n}\n"],"file":"helpers.js"}